<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Webcam Temporal Weave</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: black;
            height: 100%;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
<canvas id="weave"></canvas>
<script>
    const canvas = document.getElementById("weave");
    const ctx = canvas.getContext("2d");
    const video = document.createElement("video");
    video.autoplay = true;
    video.playsInline = true;

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resize);
    resize();

    const FRAME_COUNT = 80;
    const frameBuffer = new Array(FRAME_COUNT).fill(null);
    const tempCanvas = document.createElement("canvas");
    const tempCtx = tempCanvas.getContext("2d");

    let frameIndex = 0; // keeps track of where to store next frame
    let playbackIndex = 0; // keeps track of what frame to display
    let stepCounter = 0;

    navigator.mediaDevices.getUserMedia({ video: true, audio: false })
        .then(stream => {
            video.srcObject = stream;
            video.addEventListener("loadedmetadata", () => {
                tempCanvas.width = video.videoWidth;
                tempCanvas.height = video.videoHeight;
                animate();
            });
        })
        .catch(err => console.error("Webcam access denied:", err));

    function captureFrame() {

        frameIndex = Math.round((1 + Math.sin((stepCounter / FRAME_COUNT) * 2 * Math.PI)) * 0.5 * (FRAME_COUNT-1));
        stepCounter+=0.3;

        // capture from webcam into buffer
        tempCtx.save();
        tempCtx.scale(-1, 1); // mirror
        tempCtx.drawImage(video, -tempCanvas.width, 0, tempCanvas.width, tempCanvas.height);
        tempCtx.restore();

        frameBuffer[frameIndex] = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);

    }

    function animate() {
        captureFrame();

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const imgData = frameBuffer[playbackIndex];

        if(imgData) {
            // scale to canvas
            const scale = Math.max(canvas.width / imgData.width, canvas.height / imgData.height);
            const w = imgData.width * scale;
            const h = imgData.height * scale;
            const x = (canvas.width - w) / 2;
            const y = (canvas.height - h) / 2;

            // draw with some transparency so they blend
           // ctx.globalAlpha = 0.2;
            ctx.putImageData(imgData, 0, 0);
            //ctx.globalAlpha = 1.0;
        }
        playbackIndex = (playbackIndex + 1) % FRAME_COUNT;

        requestAnimationFrame(animate);
    }
</script>
</body>
</html>
