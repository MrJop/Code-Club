<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Predator Swarm with Inertia & Separation</title>
    <style>
        html, body {margin:0;padding:0;overflow:hidden;background:black;}
        canvas{display:block;}
    </style>
</head>
<body>
<canvas id="world"></canvas>
<script>
    const canvas = document.getElementById('world');
    const ctx = canvas.getContext('2d');

    function resize(){canvas.width=window.innerWidth;canvas.height=window.innerHeight;}
    window.addEventListener('resize', resize);
    resize();

    class Creature{
        constructor(x,y,size=1){
            this.x=x; this.y=y; this.size=size; this.color="lime";
            this.dir={x:0,y:0}; this.lastMove=performance.now(); this.lastDirectionChange=performance.now();
            this.moveDelay=75; this.setRandomDirection();
        }
        setRandomDirection(){
            const dirs=[{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1},{x:1,y:1},{x:-1,y:1},{x:1,y:-1},{x:-1,y:-1},{x:0,y:0}];
            this.dir=dirs[Math.floor(Math.random()*dirs.length)];
            this.lastDirectionChange=performance.now();
        }
        update(now){
            if(now-this.lastDirectionChange>10000)this.setRandomDirection();
            if(now-this.lastMove>this.moveDelay){
                this.x+=this.dir.x; this.y+=this.dir.y; this.lastMove=now;
                if(this.x<0)this.x=canvas.width-1;if(this.x>=canvas.width)this.x=0;
                if(this.y<0)this.y=canvas.height-1;if(this.y>=canvas.height)this.y=0;
            }
        }
        draw(){ctx.fillStyle=this.color;ctx.fillRect(this.x,this.y,this.size,this.size);}
    }

    class Predator{
        constructor(x,y){
            this.x=x; this.y=y; this.size=9; this.color="deeppink";
            this.vx=0; this.vy=0; this.maxSpeed=5; this.accel=0.3; this.drag=0.9;
            this.target=null; this.spread=false;
            this.avoidRadius=20; // separation distance
        }

        setTarget(creature){ this.target=creature; this.spread=false; }

        update(creatures,predators){
            const globalTarget=creatures.find(c=>c.size>=4)||null;
            if(globalTarget)this.target=globalTarget;
            else if(this.target && !creatures.includes(this.target)) this.target=null;

            // Hunting acceleration
            if(this.target){
                const dx=(this.target.x+this.target.size/2)-this.x;
                const dy=(this.target.y+this.target.size/2)-this.y;
                const dist=Math.sqrt(dx*dx+dy*dy);
                if(dist>0){ this.vx+=(dx/dist)*this.accel; this.vy+=(dy/dist)*this.accel; }
            }else{
                // Spread out after prey eaten
                if(!this.spread){
                    this.vx=(Math.random()*2-1)*this.maxSpeed;
                    this.vy=(Math.random()*2-1)*this.maxSpeed;
                    this.spread=true;
                }
            }

            // Separation from other predators
            predators.forEach(p=>{
                if(p===this) return;
                const dx=p.x-this.x, dy=p.y-this.y;
                const dist=Math.sqrt(dx*dx+dy*dy);
                if(dist>0 && dist<this.avoidRadius){
                    const force=(this.avoidRadius-dist)/this.avoidRadius*0.5; // small repulsion
                    this.vx-=dx/dist*force;
                    this.vy-=dy/dist*force;
                }
            });

            // Apply drag & speed limit
            this.vx*=this.drag; this.vy*=this.drag;
            const speed=Math.sqrt(this.vx*this.vx+this.vy*this.vy);
            if(speed>this.maxSpeed){ this.vx=this.vx/speed*this.maxSpeed; this.vy=this.vy/speed*this.maxSpeed; }

            this.x+=this.vx; this.y+=this.vy;

            // collision with target
            if(this.target && this.x<this.target.x+this.target.size && this.x+this.size>this.target.x &&
                this.y<this.target.y+this.target.size && this.y+this.size>this.target.y){
                const index=creatures.indexOf(this.target);
                if(index>-1){ creatures.splice(index,1); this.size+=2; }
                this.target=null; this.spread=false;
            }

            // wrap
            if(this.x<0)this.x=canvas.width-1;
            if(this.x>=canvas.width)this.x=0;
            if(this.y<0)this.y=canvas.height-1;
            if(this.y>=canvas.height)this.y=0;
        }

        drawStar(cx,cy,spikes,outerRadius,innerRadius){
            let rot=Math.PI/2*3,x=cx,y=cy; const step=Math.PI/spikes;
            ctx.beginPath(); ctx.moveTo(cx,cy-outerRadius);
            for(let i=0;i<spikes;i++){
                x=cx+Math.cos(rot)*outerRadius; y=cy+Math.sin(rot)*outerRadius; ctx.lineTo(x,y); rot+=step;
                x=cx+Math.cos(rot)*innerRadius; y=cy+Math.sin(rot)*innerRadius; ctx.lineTo(x,y); rot+=step;
            }
            ctx.lineTo(cx,cy-outerRadius); ctx.closePath(); ctx.fillStyle=this.color; ctx.fill();
        }
        draw(){this.drawStar(this.x,this.y,5,this.size/2,this.size/4);}
    }

    let creatures=[],predators=[];
    for(let i=0;i<10;i++)predators.push(new Predator(Math.random()*canvas.width,Math.random()*canvas.height));

    canvas.addEventListener('click',(e)=>{
        const rect=canvas.getBoundingClientRect();
        creatures.push(new Creature(e.clientX-rect.left,e.clientY-rect.top));
    });

    function checkCollisions(){
        for(let i=0;i<creatures.length;i++){
            for(let j=i+1;j<creatures.length;j++){
                const a=creatures[i],b=creatures[j];
                if(a.x<b.x+b.size && a.x+a.size>b.x && a.y<b.y+b.size && a.y+a.size>b.y){
                    const merged=new Creature((a.x+b.x)/2,(a.y+b.y)/2,a.size+b.size);
                    creatures.splice(j,1); creatures.splice(i,1,merged); return;
                }
            }
        }
    }

    function loop(){
        ctx.fillStyle="rgba(0,0,0,0.3)"; ctx.fillRect(0,0,canvas.width,canvas.height);
        const now=performance.now();
        creatures.forEach(c=>c.update(now)); checkCollisions(); creatures.forEach(c=>c.draw());
        predators.forEach(p=>{p.update(creatures,predators); p.draw();});
        requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);
</script>
</body>
</html>
