<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pixel Creatures with Predator</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: black;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
<canvas id="world"></canvas>
<script>
    const canvas = document.getElementById('world');
    const ctx = canvas.getContext('2d');

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    class Creature {
        constructor(x, y, size = 1) {
            this.x = x;
            this.y = y;
            this.size = size;
            this.color = "lime";
            this.dir = {x: 0, y: 0};
            this.setRandomDirection();
            this.lastDirectionChange = performance.now();
            this.lastMove = performance.now();
            this.moveDelay = 75; // faster, smoother
        }

        setRandomDirection() {
            const dirs = [
                {x: 1, y: 0}, {x: -1, y: 0},
                {x: 0, y: 1}, {x: 0, y: -1},
                {x: 1, y: 1}, {x: -1, y: 1},
                {x: 1, y: -1}, {x: -1, y: -1},
                {x: 0, y: 0} // pause
            ];
            this.dir = dirs[Math.floor(Math.random() * dirs.length)];
            this.lastDirectionChange = performance.now();
        }

        update(now) {
            if (now - this.lastDirectionChange > 10000) {
                this.setRandomDirection();
            }

            if (now - this.lastMove > this.moveDelay) {
                this.x += this.dir.x;
                this.y += this.dir.y;
                this.lastMove = now;

                if (this.x < 0) this.x = canvas.width - 1;
                if (this.x >= canvas.width) this.x = 0;
                if (this.y < 0) this.y = canvas.height - 1;
                if (this.y >= canvas.height) this.y = 0;
            }
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, this.size, this.size);
        }
    }

    class Predator {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.size = 9;
            this.color = "deeppink";
            this.speed = 400;
            this.lastMove = performance.now();
            this.target = null;
        }

        findTarget(creatures) {
            this.target = creatures.find(c => c.size >= 4) || null;
        }

        update(now, creatures) {
            if (!this.target || !creatures.includes(this.target)) {
                this.findTarget(creatures);
            }

            if (now - this.lastMove > this.speed) {
                if (this.target) {
                    if (this.x < this.target.x) this.x++;
                    else if (this.x > this.target.x) this.x--;
                    if (this.y < this.target.y) this.y++;
                    else if (this.y > this.target.y) this.y--;

                    // Check collision
                    if (
                        this.x < this.target.x + this.target.size &&
                        this.x + this.size > this.target.x &&
                        this.y < this.target.y + this.target.size &&
                        this.y + this.size > this.target.y
                    ) {
                        const index = creatures.indexOf(this.target);
                        if (index > -1) {
                            creatures.splice(index, 1);
                            this.size += 2; // grow when eating
                        }
                        this.target = null;
                    }
                } else {
                    this.x += Math.floor(Math.random() * 3) - 1;
                    this.y += Math.floor(Math.random() * 3) - 1;
                }

                if (this.x < 0) this.x = canvas.width - 1;
                if (this.x >= canvas.width) this.x = 0;
                if (this.y < 0) this.y = canvas.height - 1;
                if (this.y >= canvas.height) this.y = 0;

                this.lastMove = now;
            }
        }

        drawStar(cx, cy, spikes, outerRadius, innerRadius) {
            let rot = Math.PI / 2 * 3;
            let x = cx;
            let y = cy;
            const step = Math.PI / spikes;

            ctx.beginPath();
            ctx.moveTo(cx, cy - outerRadius);
            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius;
                y = cy + Math.sin(rot) * outerRadius;
                ctx.lineTo(x, y);
                rot += step;

                x = cx + Math.cos(rot) * innerRadius;
                y = cy + Math.sin(rot) * innerRadius;
                ctx.lineTo(x, y);
                rot += step;
            }
            ctx.lineTo(cx, cy - outerRadius);
            ctx.closePath();
            ctx.fillStyle = this.color;
            ctx.fill();
        }

        draw() {
            this.drawStar(this.x, this.y, 5, this.size / 2, this.size / 4);
        }
    }

    let creatures = [];
    const predator = new Predator(canvas.width / 2, canvas.height / 2);

    canvas.addEventListener('click', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = Math.floor(e.clientX - rect.left);
        const y = Math.floor(e.clientY - rect.top);
        creatures.push(new Creature(x, y));
    });

    function checkCollisions() {
        for (let i = 0; i < creatures.length; i++) {
            for (let j = i + 1; j < creatures.length; j++) {
                const a = creatures[i];
                const b = creatures[j];
                if (a.x === b.x && a.y === b.y) {
                    const merged = new Creature(a.x, a.y, a.size + b.size);
                    creatures.splice(j, 1);
                    creatures.splice(i, 1, merged);
                    return;
                }
            }
        }
    }

    function loop(now) {
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        creatures.forEach(c => c.update(now));
        checkCollisions();
        creatures.forEach(c => c.draw());

        predator.update(now, creatures);
        predator.draw();

        requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);
</script>
</body>
</html>
