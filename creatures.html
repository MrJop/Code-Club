<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Canvas Creatures with Glow & Trails</title>
    <style>
        html,body {
            margin:0;
            height:100%;
            background:#000;
            display:flex;
            justify-content:center;
            align-items:center;
        }
        canvas {
            background:#000;
            border:1px solid rgba(255,255,255,0.2);
            border-radius:14px;
            display:block;
        }
    </style>
</head>
<body>
<canvas id="stage" width="1100" height="600"></canvas>

<script>
    const canvas = document.getElementById('stage');
    const ctx = canvas.getContext('2d');

    const numCreatures = 50;
    const triggerDistance = 40;
    const radius = 6;

    const colorSteps = [
        [0,0,0],       // black
        [85,0,0],      // dark red
        [170,34,0],    // red/orange
        [255,102,0],   // orange
        [255,170,0],   // yellow-orange
        [255,255,0],   // yellow
        [255,255,136], // pale yellow
        [255,255,255]  // white
    ];

    function rgbString([r,g,b], alpha=1) {
        return `rgba(${r},${g},${b},${alpha})`;
    }

    function lerpColor(a,b,t) {
        return [
            Math.round(a[0] + (b[0]-a[0])*t),
            Math.round(a[1] + (b[1]-a[1])*t),
            Math.round(a[2] + (b[2]-a[2])*t)
        ];
    }

    function brighten([r,g,b], factor=1.3) {
        return [
            Math.min(255, Math.round(r*factor)),
            Math.min(255, Math.round(g*factor)),
            Math.min(255, Math.round(b*factor))
        ];
    }

    function createCreature() {
        return {
            x: Math.random()*canvas.width,
            y: Math.random()*canvas.height,
            vx: (Math.random()*2-1) * 50,
            vy: (Math.random()*2-1) * 50,
            interactions: 0,
            color: [0,0,0],
            targetColor: [0,0,0],
            colorProgress: 1,
            pulse: 0,
            falling: false,
            vyFall: 0,
            flickerTimer: 0,
            deadOnFloor: false,
            fade: 1 // opacity while fading
        };
    }

    const creatures = [];
    for (let i=0; i<numCreatures; i++) {
        creatures.push(createCreature());
    }

    const activePairs = new Set();
    function pairKey(i,j){ return i<j ? `${i}-${j}` : `${j}-${i}`; }

    function checkInteractions() {
        for (let i=0;i<creatures.length;i++){
            for (let j=i+1;j<creatures.length;j++){
                const a = creatures[i], b = creatures[j];
                if (a.falling || b.falling || a.deadOnFloor || b.deadOnFloor) continue;
                const dx = a.x-b.x, dy=a.y-b.y;
                const dist = Math.sqrt(dx*dx+dy*dy);
                const key = pairKey(i,j);
                if (dist<triggerDistance){
                    if (!activePairs.has(key)){
                        activePairs.add(key);
                        a.interactions++;
                        b.interactions++;
                        triggerInteraction(a);
                        triggerInteraction(b);
                    }
                } else {
                    activePairs.delete(key);
                }
            }
        }
    }

    function triggerInteraction(c){
        const index = Math.min(c.interactions, colorSteps.length-1);
        c.color = c.targetColor;
        c.targetColor = colorSteps[index];
        c.colorProgress = 0;
        c.pulse = 1;
        if (index === colorSteps.length-1 && !c.falling){
            c.falling = true;
            c.vx = 0;
            c.vyFall = 50;
        }
    }

    function update(dt){
        for (const c of creatures){
            if (c.deadOnFloor){
                c.fade -= dt*0.2;
                if (c.fade <= 0){
                    Object.assign(c, createCreature());
                }
                continue;
            }

            if (c.falling){
                c.vyFall += 300*dt;
                c.y += c.vyFall*dt;
                if (c.y >= canvas.height-radius){
                    c.y = canvas.height-radius;
                    c.falling = false;
                    c.deadOnFloor = true;
                    c.fade = 1;
                }
            } else {
                c.x += c.vx*dt;
                c.y += c.vy*dt;
                if (c.x<radius){c.x=radius;c.vx=Math.abs(c.vx);}
                if (c.x>canvas.width-radius){c.x=canvas.width-radius;c.vx=-Math.abs(c.vx);}
                if (c.y<radius){c.y=radius;c.vy=Math.abs(c.vy);}
                if (c.y>canvas.height-radius){c.y=canvas.height-radius;c.vy=-Math.abs(c.vy);}
            }

            if (c.colorProgress<1){
                c.colorProgress = Math.min(1,c.colorProgress+dt*2.5);
            }

            if (c.pulse>0){
                c.pulse = Math.max(0,c.pulse - dt*5);
            }
        }
    }

    function draw(){
        // Fade overlay for trails
        ctx.fillStyle = "rgba(0,0,0,0.2)";
        ctx.fillRect(0,0,canvas.width,canvas.height);

        for (const c of creatures){
            let col = c.color;
            if (c.colorProgress<1){
                col = lerpColor(c.color,c.targetColor,c.colorProgress);
            } else {
                col = c.targetColor;
            }

            if (c.falling && c.interactions >= colorSteps.length-1){
                c.flickerTimer += 1;
                if ((c.flickerTimer>>2)%2===0) col=[255,255,255];
                else col=[0,255,0];
            }

            const scale = 1 + 0.15*c.pulse;
            const glowCol = brighten(col,1.5);

            ctx.beginPath();
            ctx.arc(c.x,c.y,radius*scale,0,Math.PI*2);

            ctx.shadowBlur = 10;
            ctx.shadowColor = rgbString(glowCol, c.fade);
            ctx.fillStyle = rgbString(col, c.fade);
            ctx.fill();

            ctx.shadowBlur = 0; // reset
        }
    }

    let last=performance.now();
    function loop(now){
        const dt=(now-last)/1000; last=now;
        update(dt);
        checkInteractions();
        draw();
        requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
</script>
</body>
</html>
